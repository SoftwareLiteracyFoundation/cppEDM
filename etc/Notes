
General notes

1) The OSX XCode compiler/linker seems to be incompatible with the C++11
   standard implementation allowing template classes to be distributed into
   declarations (.h) and implementation (.cc).  However, this does entail
   explicit declaration of specialised template types in the .cc file.
   To support OSX, DataFrame.h contains both declarations and implementations.
   See: libstdc++_Notes.txt.

2) The code relies heavily on class and data containers without explicit
   heap allocation.  This facilitates garbage collection.  It may be that
   copy-on-return for large data objects creates a performance issue.
   If the code encounters massive data objects/large problems, this may
   pose a limitation.  The use of object references may alleviate this.

3) The LAPACK library is used for the S-map solver. It calls the dgelss_()
   FORTRAN function.  On nix systems, OS-installed libraries are used.
   On Windows, the Windows for LAPACK libraries are needed.  These are
   built with mingw, so mingw libraries must be available.  It further
   seems that the mingw 32-bit libraries have to be used. See below. 

4) pyEDM implements a wrapper for cppEDM using PyBind11. This requires
   a MSVC build since Python extensions must be compiled with the same
   compiler as the Python interpreter. 

5) rEDM implements a wrapper for cppEDM using Rcpp. R includes the
   RTools package for building Windows binaries, and, it's own
   LAPACK libraries. 



--------------------------------------------------------------------
CCM vs Simplex : lib, pred and libSize compatibility
--------------------------------------------------------------------

Time delay embedding removes the first tau(E-1) rows of data to exclude
partial data vectors. Accordingly, the maximum index of lib or pred
rows allowed is the number of data observation rows minus tau(E-1). 

If Tp > 0, then Tp additional rows are forecast beyond pred.

Simplex() is a wrapper for SimplexProjection(). With default embedded = false
it embeds the data and performs cross mapping from lib NN at each pred
observation with a call to SimplexProjection(). The lib and pred indices are
adjusted to account for the removal of partial data vectors so that output
data align with the observations.  

Simplex with E = 3, Tp = 0, lib = pred = "1 10" on a dataset with 12
observation rows will have a NN library of size 8 = 10 - 2 from embedding
of the first 10 observation rows.  Predictions will be output at rows
3 - 10 since the max pred is 10 and the first two observations were deleted
as partial data E-dimensional vectors where no neighbors can be computed. 

CCM() embeds the entire data, then uses the embedding size (rows) as both
lib and pred to perform cross mapping with a call to SimplexProjection()
using embedded = true (no embedding performed on data). If random = false
then lib is assigned sequentially up to the current library size. There
is no external notion of lib & pred.

CCM with E = 3 and libSizes = "10 10 1", random = false, will read the 12
observation rows, perform embedding discarding the first two rows, then
predict 10 points at a library size of 10 using sequential lib indices.

CCM was not intended to be used for non-convergent cross mapping and has
no notion of pred, only library size.  As a result, it does not have the
same alignment of lib & pred as in Simplex(), and, forms the embedding
based on all available observations (not just lib). 

Continuing with the 12 observation data, 10 analysis row example, the
following parameter combinations give congruent rho results:

******** Tp = 0 **********
Simplex: data.csv lib = "1 10" pred = "3 12" columns = x target = y
E = 3 Tp = 0
rho   0.911001  RMSE   0.259461  MAE   0.198365

CCM: data.csv columns = x target = y E = 3 Tp = 0 libSizes = "10 10 1"
----------------------------------------------
      10.0000       0.9110       0.5470
----------------------------------------------

******** Tp = 1 **********
Simplex: data.csv lib = "1 10" pred = "3 11" columns = x target = y
E = 3 Tp = 1
rho   0.868089  RMSE   0.198611  MAE   0.15669

CCM: data.csv columns = x target = y E = 3 Tp = 1 libSizes = "9 9 1"
----------------------------------------------
       9.0000       0.8681       0.7016
----------------------------------------------

******** Tp = 2 **********
Simplex: data.csv lib = "1 10" pred = "3 10" columns = x target = y
E = 3 Tp = 2
rho   0.831373  RMSE   0.170693  MAE   0.132672

CCM: data.csv columns = x target = y E = 3 Tp = 2 libSizes = "8 8 1"



--------------------------------------------------------------------
Building etc/Test.cc on Windows
--------------------------------------------------------------------

This has been found to work on Windows 10 with MSVC 2019 build tools
and mingw. 

   Build cppEDM/src:
   nmake /f makefile.windows

   Compile cppEDM/etc/Test.cc into Test.obj:
   cl /c Test.cc /EHsc /MD /I../src

   Download .lib and .dll from Windows for LAPACKE:
   https://icl.cs.utk.edu/lapack-for-windows/lapack/#lapacke
   Copy .dll and .lib from LAPACKE_examples.zip into ../../lapacke

   Link Test.obj into Test.exe:
   link /OUT:Test.exe /LIBPATH:../lib /LIBPATH:../../lapacke EDM.lib
   liblapack.lib Test.obj

   Get missing libraries for LAPACK legacy:
   Downloaded libgfortran-3.dll into ../../lapacke
   https://www.opendll.com/index.php?file-download=libgfortran-3.dll&arch=32bit

   Downloaded libwinpthread-1.dll into ../../lapacke
   https://wikidll.com/mingw-w64/libwinpthread-1-dll

   Set PATH to find the lapacke and mingw dll's:
   PATH=../../lapacke;C:\MINGW\BIN;%PATH%

   Run Test.exe
